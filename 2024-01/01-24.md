# 객체 지향 프로그래밍

## 절차 지향 프로그래밍(Procedural Programming)

> 프로그램을 '데이터'와 '절차'로 구성하는 방식의 프로그래밍 패러다임

### 절차 지향 프로그래밍 특징

> '데이터'와 해당 데이터를 처리하는 '함수(절차)'가 분리되어 있으며, 함수 호출의 흐름이 중요

> 코드의 순차적인 흐름과 함수 호출에 의해 프로그램 진행

> 실제로 실행되는 내용이 무엇인가가 중요

> 데이터를 다시 재사용하거나 하기 보다는 첨부터 끝까지 실행되는 결과물이 중요한 방식

### 소프트웨어 위기

> 하드웨어의 발전으로 복잡성 증가 -> 소프트웨어 프로그램 다운 현상

## 객체 지향 프로그래밍(Object Oriented Programming)

> 데이터와 해당 데이터를 조작하는 메서드를 **하나의 객체로 묶어** 관리하는 방식의 프로그래밍 패러다임

### 절차 vs 객체 지향

![절차객차](https://github.com/Demopeu/TLI/assets/156268475/abfc63b5-b898-4642-87dd-864ee331ebf2)

```
절차: 함수,데이터
데이터와 해당 데이터를 처리하는 함수가 분리
ex. 공격을 한다 전사가


객체: 객체 중심
데이터와 메서드를 객체로 묶음
ex. 전사가 베기를 한다
```

---

# 객체

> 클래스에서 정의한 것을 토대로 **메모리에 할당**된 것

>> (클래스는 아래에서 정리)

> **속성**과 **메서드**으로 구성된 모든 것

``클래스 안에 직접적으로 객체가 들어가는 것이 아닌, 클래스는 객체를 생성하기 위한 탬플릿 또는 설계도 역할``

## 객체의 특징

> 타입: 연산자와 조작

> 속성: 데이터

> 조작법: 함수

> 파이썬의 객체 = 속성 + 조작법

## 클래스와 객체

> 클래스로 만든 객체를 **인스턴스** 라고 함

> 클래스도 객체이기 때문에, 클래스로 만든 객체를 따로 분류하는 것

```
아이유는 객체다(0)
아이유는 인스턴스다(X)
아이유는 가수의 인스턴스다(0)
가수는 객체이다(0)

주의!! 절대 집합 마냥 포함 관계가 아님 
```

``name = 'kim' ``

> 변수 name의 타입은 str 클래스이다.

> 변수 name은 **str 클래스의 인스턴스**이다.

> 우리가 사용해왔던 **데이터 타입은 사실 모두 클래스**였다!

> 결국 문자열 타입의 변수는 str 클래스로 만든 **인스턴스**

> list 타입의 객체(ex. [1])

## 인스턴스와 메서드

> 클래스 안에 있는 함수를 메서드

> 인스턴스.메서드()

``하나의 객체는 특정 타입의 인스턴스``

---

# 클래스

> 파이썬에서 타입을 표현하는 방법

>> 객체를 생성하기 위한 설계도

>> 데이터와 기능을 함께 묶는 방법을 제공

```
class Person:
    pass

iu = Person()

iu.메서드()

iu.attribute
```

## 클래스 기본 활용

![클래스의 기본 활용](https://github.com/Demopeu/TLI/assets/156268475/c43325ab-0d26-445a-95de-a9588d9bf0b3)

- 생성자 함수

```
def __init__(self,name):
        self.name = name
```

> 객체를 생성할 때 (특정 타이밍에)자동으로 호출되는 특별한 메서드

> `` __init__ `` 이라는 이름의 메서드롤 정의

> 인스턴스를 생성, 필요한 초기값 설정

- 인스턴스 변수

``self.name = name``

> 인스턴스마다 별로도 유지되는 변수

> 인스턴스 마다 독립적인 값을 가지며, 인스턴스가 생성될 때 마다 초기화

- 클래스 변수

``blood_color = 'red``

>  클래스 내부에 선언된 변수

> 모든 인스턴스들이 공유

- 인스턴스 메서드

```
def singing(self):
      return (이하생략)
```

> 각각의 인스턴스에서 호출할 수 있는 메서드

## 인스턴스와 클래스 간의 이름 공간(namespace)

- 클래스 정의시, 클래스와 해당하는 이름 공간 생성

- 인스턴스를 만들면, 인스턴스 객체가 생성되고 **독립적인** 이름 공간 생성

- 인스턴스에서 특정 속성에 접근시, 인스턴스->클래스 순으로 탐색

### 독립적인 이름공간을 가지는 이점

> 서로의 데이터나 상태에 직접적인 접근이 불가능

> 객체 지향 프로그래밍이 중요한 특성 중 하나

> 클래스와 인스턴스를 모듈화 하고 각각의 객체가 독립적으로 동작하도록 보장

``코드의 가독성, 유지보수성, 재사용성을 높이는데 도움``

## 인스턴스 변수와 클래스 변수

> self가 붙는게 인스턴스 함수

```
class Circle():
    pit = 3.14

    def __init__(self, r):
        self.r = r

c1 = Circle(5)
c2 = Circle(10)

print(Circle.pi) # 3.14
print(c1.pi) # 3.14

c2.pi = 5 # 인스턴스 변수 변경
print(Circle.pi) # 3.14
print(c1.pi) # 3.14
print(c2.pi) # 5

Circle.pi = 5 # 클래스 변수 변경
print(Circle.pi) # 5
print(c1.pi) # 5
```

---

# 메서드

## 메서드의 종류

- 인스턴스 메서드

- 클래스 메서드

- 정적 메서드

### 인스턴스 메서드

> 인스턴스에서 호출할 수 잇는 메서드

>> 인스턴스의 상태를 조작하거나 동작을 수행

#### 인스턴스 메서드 구조

> 클래스 내부에 정의 되는 메서드의 기본

> 반드시 첫 번째 매개 변수로 인스턴스 자신(self)을 전달받음

```
class Myclass:

    def instance_method(self, arg1,...):
        pass
```

##### **self 동작 원리**

```
ex. upper의 동작

우리가 적는거
'hello'.upper()
->
실제 내부 동작
str.upper('hello')

따라서 self가 들어와야함
이것을 단축형 호출
솔직히 self는 매개변수라 이름 마음대로 가능
하지마 절대 그러지 않음. 약속함
```
#### 생성자 메서드

> 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드

>> 인스턴스 변수들의 초기값을 설정

### 클래스 메서드

> 클래스가 호출하는 메서드

>> 클래스 변수를 조작하거나 크래릇 레벨의 동작을 수행

#### 클래스 메서드 구조

> @classmethod 데코레이터를 사용하여 정의

> 호출 시, 첫번째 인자가 호출하는 클래스(cls)가 전달됨

```
class Myclass
    
    @classmethod
    def class_method(cls,arg1):
        print(f'인구수는{cls.count}입니다.')

이때 cls.count를 Person.count해도되긴하는데 사용하면 위에 __init__같은거 적용이 안됨
```

### 정적 메서드

> **클래스와 인스턴스와 상관없이 독립적**으로 동작하느 메서드

>> 주로 클래스와 관련이 있지만 인스턴스와 상호작용이 필요하지 않은 경우에 사용

> @stticmethod 데코레이터를 사용

> 호출 시 필수 X

> 수정 X, 단지 기능만을 위한 메서드

## 메서드 정리

- 인스턴스 메서드: 인스턴스 상태 변경, 특정 동작 수행

- 클래스 메서드: 인스턴스 상태 의존X, 클래스 레벨 동작 수행

- 스태틱 메서드: 클래스, 인스턴스 관련 없는 일반적인 기능 수행

---

# 참고

## 매직 메서드

- 인스턴스 메서드

- 특정 상호아에서 자동으로 호출되는 메서드

- Double undescore(__)가 있는 메서드는 특수한 동작을 위해 만들어진 메서드

- 스페셜 혹은 메직 메서드라고 불림

## 데코레이터

- 다른 함수의 코드를 유지한 채로 수정하거나 확장하기 위해 사용되는 함수

- 인자로 함수를 받음

```
def my_decorator(func):
    def wrapper():
        print('함수 실행 전')
        result = func()
        print('함수 실행 후')
        return result

    return wapper

@my_decorator
def my_function():
    print('원본 함수 실행')

my_function()

#
함수 실행 전
원본 함수 실행
함수 실행 후

```

