# 알고리즘

> 유한한 단계를 통해 **문제를 해결하기 위한 절차나 방법**

>> 어떠한 문제를 해결하기 위한 절차

## 알고리즘 표현법

> 의사코드(슈도코드)

> 순서도

## 좋은 알고리즘

> 정확성(정확하게 동작)

> 작업량(적은 연산)

> 메모리 사용량(적은 메모리)

> 단순성(단순)

> 최적성(최적화)

## 시간 복잡도

> 실제 걸리는 시간을 측정

> 실행되는 명령문의 개수를 계산

### 빅 오(O)표기법

> 가장 큰 영향력을 주는 n에 대한 항만을 표시

![복잡도](https://github.com/Demopeu/TLI/assets/156268475/ff0e83de-fe25-4b30-8568-027f944f20b3)

---

# 배열

> 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

> 하나의 배열 선언에 둘 이상의 변수 선언

> 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 해결

---

# 정렬

> 2개 이상의 자료를 특정 기준에 의해 작은 값 부터 큰 값, 혹은 그 반대로 재배열 하는 것

## 버블 정렬

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

> O(n^2)

## 카운팅 정렬

> 항목들의 순서를 결정하기 위해 항목의 개수를 세고, 선형 시간에 정렬하는 효율적인 알고리즘

> 정수나 정수 표현 자료에서만 적용

>O(n+k) n은 리스트의 길이, k는 정수의 최대값

1. 각 항목들의 발생 회수 세고, 직접 인덱스 되는 카운트 배열 저장

![1](https://github.com/Demopeu/TLI/assets/156268475/71551aca-2620-45e5-8f86-808a0461b203)

2. 개수 반영을 위한 원소 조정

![2](https://github.com/Demopeu/TLI/assets/156268475/b3f9ea7d-9d2f-4c53-9f41-f590454c96e6)


3. counts[1]을 감소 시키고 새로운 정렬에 1을 삽입

> 기존 DATA의 뒤부터 감소 시키고 새로운 정렬

4. counts[0,1,4,5,6] 이 되며, 새로운 정렬은 [0,1,1,1,2,3,4,4]로 생성

---

# 그리드 알고리즘

> 그리드 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
