# 패턴 매칭

> 패턴 매칭에 사용되는 알고리즘들

1. 고지식한 패턴 검색 알고리즘

> 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작

> 최악의 경우 모든 텍스트 패턴 비교해야기 때문에 O(MN)

2. 카프-라빈 알고리즘

3. NMP 알고리즘

4. 보이어-무어 알고리즘

## KMP 알고리즘

> 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 무자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행

> 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함

> 시간 복잡도: O(N+M)

**파이 배열**

> 파이 배열의 i번째 성분은, 문자열의 i번째까지의 부분 문자열에서 접두사, 접미사가 같아지는 최대 길이

> 접두,접미사를 확인하고 jump!

```
i   부분 문자열     P[i]
0   a               0
1   ab              0
2   aba             1
3   abab            2
4   ababb           0
5   ababba          1
6   ababbab         2
```

```
pattern = 'ababbab'

table = [0 for _ range(len(pattern))]
i = 0
for j in range(1,len(pattern)):
    while i > 0 and pattern[i] != pattern[j]:
        i = table[i-1]

    if pattern[i] == pattern[j]:
        i +=1
        table[j] = i

print(table)
```

## 보이어 무어 알고리즘

> 오른쪽 끝부터 왼쪽으로 비교

> 뒤에서부터 비교하다가 틀리는 부분이 나오면 마지막 글자와 찾는 문자열 중 일치하는 글자가 있는 곳까지 쉬프트

> 일치하는 부분 없으면 문자열 길이 만큼 이동

> skip 배열을 미리 설정

![보이어무어알고리즘](https://github.com/Demopeu/TLI/assets/156268475/1d33275a-3fe4-42b4-bd9f-532a42225a83)

> 다른 모든 문자에 대하여 skip을 하므로 모든 문자 안봐도 됨

---

# 문자열 암호화

> 시저 암호

>> 평문에서 사용되고 있는 알파벳을 일정한 문자 수만큼 [평행이동] 시킴으로써 암호화

## 단일 치환 암호

> 문자 변환표를 이용한 암호화

> 복호화 하기 위해서는 모든 키의 조합 필요(26!의 암호키)

## bit열의 암호화

> 배타적 논리합 연산 사용

## 저장소 크기를 줄이는 알고리즘

> Run-length encoding 알고리즘

>> 같은 값이 몇 번 반복되는가

>> 이미지 파일 포맷

> 허프만 코딩 알고리즘
